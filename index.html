<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>@dtienioscheat</title>
  <style>
    .rainbow-text {
  background: linear-gradient(
    270deg,
    #ff0000, #ff7300, #ffeb00, #47ff00, #00ffee,
    #2b65ff, #8000ff, #ff00c8, #ff0000, #ff7300,
    #ffeb00, #47ff00, #00ffee, #2b65ff, #8000ff,
    #ff00c8, #ff0000, #ff7300, #ffeb00, #47ff00
  );
  background-size: 400% 400%;
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  animation: rainbowMove 8s ease infinite;
  font-weight: bold;
}

@keyframes rainbowMove {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}

    body {
      margin: 0;
      padding: 0;
      height: 100vh;
      background: url('https://i.imgur.com/ypiB0XP.jpg') no-repeat center center fixed;
      background-size: cover;
      font-family: Arial, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      overflow: hidden;
    }

    * {
      color: #17b6b6;
      font-size: 15px;
      font-family: Courier;
      -webkit-tap-highlight-color: transparent;
      outline: none;
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    #login-form, #content-view {
        background: transparent; /* n·ªÅn trong su·ªët */
        border: 2px solid rgba(255, 255, 255, 0.2); /* vi·ªÅn tr·∫Øng nh·∫π 20% cho ƒë·∫πp */
      border-radius: 5px;
      padding: 20px;
      max-width: 90%;
      text-align: center;
      z-index: 1;
    }

    input[type="text"], input[type="password"] {
      width: 80%;
      padding: 0.5rem;
      margin: 0.5rem 0;
      border-radius: 0.5rem;
      border: 1px solid #17b6b6;
      background: transparent;
      color: #17b6b6;
    }

    input[type="button"], button {
      width: 80%;
      height: 2.5rem;
      color: #ffffff;
      background-color: rgba(24, 7, 73, 0.8);
      cursor: pointer;
      text-align: center;
      border: none;
      border-radius: 1.5rem;
      padding: 0 1rem;
      margin: 0.5rem 0;
      font-size: 1rem;
      transition: all 0.3s ease;
    }

    button:active, input[type="button"]:active {
      transform: translateY(2px);
    }

    select {
      width: 200px;
      padding: 5px;
      font-size: 16px;
      margin-top: 10px;
    }

    input[type="range"] {
      width: 80%;
      margin: 10px 0;
      accent-color: #17b6b6;
    }

    .range-label {
      margin-top: 5px;
      font-size: 14px;
      color: #ffffff;
    }

    @media screen and (min-width: 768px) {
      #login-form, #content-view { max-width: 70%; }
    }

    @media screen and (min-width: 1024px) {
      #login-form, #content-view { max-width: 50%; }
    }

    .gradient-text {
      background: linear-gradient(270deg, orange, red, orange);
      background-size: 600% 600%;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: gradientMove 4s ease infinite;
      font-size: 1.8rem;
      font-weight: bold;
      margin-bottom: 20px;
    }

    @keyframes gradientMove {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    #stars {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0; /* ph√≠a d∆∞·ªõi n·ªôi dung */
      background: transparent;
    }
  </style>

  <script>
    function login() {
      const username = document.getElementById("username").value;
      const password = document.getElementById("password").value;
      if (username === "nhavuadtien" && password === "basan11") {
        alert("ƒêƒÇNG NH·∫¨P TH√ÄNH C√îNG V√Ä ƒê∆Ø·ª¢C CHO PH√âP S·ª¨ D·ª§NG B·ªûI TI·∫æN B·ªäP üåü");
        localStorage.setItem("username", username);
        localStorage.setItem("password", password);
        document.getElementById("login-form").style.display = "none";
        document.getElementById("content-view").style.display = "block";
      } else {
        alert("SAI USERNAME HO·∫∂C PASSWORD, VUI L√íNG TH·ª¨ L·∫†I!");
      }
    }

    function activateFeature(button) {
      alert("K√≠ch ho·∫°t th√†nh c√¥ng ü™ô");
      button.style.backgroundColor = "green";
      button.innerText += " ‚úÖ";
      button.disabled = true;
    }

    function updateRangeValue(id, labelId) {
      const value = document.getElementById(id).value;
      document.getElementById(labelId).innerText = value;
    }

    window.onload = function () {
      const savedUsername = localStorage.getItem("username");
      const savedPassword = localStorage.getItem("password");
      if (savedUsername && savedPassword) {
        document.getElementById("username").value = savedUsername;
        document.getElementById("password").value = savedPassword;
      }
    }
  </script>
</head>

<body>
  <canvas id="stars"></canvas>

  <form id="login-form">

    <h2 class="gradient-text">MENU TIEN BIP ‚öúÔ∏è</h2>
    <label for="username">ùêîùê¨ùêûùê´ùêßùêöùê¶ùêû</label><br>
    <input type="text" id="username" name="username" required><br><br>

    <label for="password">ùêèùêöùê¨ùê¨ùê∞ùê®ùê´ùêù</label><br>
    <input type="password" id="password" name="password" required><br><br>

    <input type="button" value="ùêãùê®ùê†ùê¢ùêß" onclick="login()"><br>

    <button style="background-color: rgb(196, 185, 185);height: 30px;width: 80px;border-radius: 10px;">
      <a href="https://zalo.me/0378813029" style="text-decoration: none;color: black;">ùêÄùêùùê¶ùê¢ùêß</a>
    </button>
  </form>

  <div id="content-view" style="display: none;">
    <h2 class="gradient-text">MENU TIEN BIP ‚öúÔ∏è</h2>

    <div id="clock" class="rainbow-text" style="font-size: 1.2rem; margin-bottom: 20px;"></div>

    <div>
      <label for="resolution">Change Resolution: <span id="resolutionValue">60</span></label><br>
      <input type="range" id="resolution" min="1" max="120" value="60" oninput="updateRangeValue('resolution', 'resolutionValue')">
    </div>

    <div>
      <label for="dpi">Optimized DPI: <span id="dpiValue">60</span></label><br>
      <input type="range" id="dpi" min="1" max="120" value="60" oninput="updateRangeValue('dpi', 'dpiValue')">
    </div>

    <audio controls autoplay>
      <source src="https://files.catbox.moe/tevv96.mp3" type="audio/mpeg">
    </audio>

    <button onclick="activateFeature(this)">Boost GPU</button>
    <button onclick="activateFeature(this)">xuy√™n gi√°p</button>
    <button onclick="activateFeature(this)">Safe Code</button>
    <button onclick="activateFeature(this)">ghim ƒë·∫ßu</button>
    <button onclick="activateFeature(this)">Creative Newest</button>

    <label for="appSelect" style="display: block; margin-top: 20px;">VERSION:</label>
    <select id="appSelect">
      <option value="auto">T·ª∞ ƒê·ªòNG</option>
      <option value="freefire">com.dts.freefireth</option>
      <option value="freefiremax">com.dts.freefiremax</option>
    </select>

    <p class="rainbow-text" style="margin-top: 20px;">Dev: Tien bip dep trai üê≥</p>

  </div>

  <script>
    const canvas = document.getElementById('stars');
    const ctx = canvas.getContext('2d');
    let stars = [];
    let numStars = 100;

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
function aimAtHead(input, head, options = {}) {
    const boost = options.boost ?? 6.5;        // 3 ‚Äì 15
    const smoothing = options.smoothing ?? 0.38;

    // 1. Predict
    const predicted = predictHead(head);

    // 2. Vector
    let dx = predicted.x - input.x;
    let dy = predicted.y - input.y;

    const distance = Math.hypot(dx, dy);

    // 3. Dynamic clamp
    dx = dynamicClamp(dx, distance);
    dy = dynamicClamp(dy, distance);

    // 4. Boost scale theo distance (ch·ªëng vƒÉng)
    const distanceScale = Math.min(1, distance / 120);

    const target = {
        x: input.x + dx * boost * distanceScale,
        y: input.y + dy * boost * distanceScale * 0.97 // c·ªï‚Äìƒë·∫ßu
    };

    // 5. EMA smoothing
    return emaSmooth(target, smoothing);
}
function optimizeAim(input, target, settings = {}) {
    const boost = settings.boost ?? 6.0;
    const smoothing = settings.smoothing ?? 0.35;

    let dx = target.x - input.x;
    let dy = target.y - input.y;

    const distance = Math.hypot(dx, dy);

    const clamp = Math.max(2, distance * 0.3);
    dx = Math.max(-clamp, Math.min(clamp, dx));
    dy = Math.max(-clamp, Math.min(clamp, dy));

    const scale = Math.min(1, distance / 120);

    return {
        x: input.x + dx * boost * scale * smoothing,
        y: input.y + dy * boost * scale * smoothing * 0.97
    };
}
}
    function enhanceSensitivity(delta, strength = 1.4) {
    return {
        x: Math.sign(delta.x) * Math.pow(Math.abs(delta.x), 0.85) * strength,
        y: Math.sign(delta.y) * Math.pow(Math.abs(delta.y), 0.85) * strength
    };
}
    
    function fixOvershoot(input, output, max = 0.6) {
    const dx = output.x - input.x;
    const dy = output.y - input.y;
    const distance = Math.hypot(dx, dy);

    const scale = Math.min(1, max + distance * 0.002);

    return {
        x: input.x + dx * scale,
        y: input.y + dy * scale
    };
}
    
let last = null;

function screenSmoothFrame(target, alpha = 0.35) {
    if (!last) {
        last = { ...target };
        return target;
    }

    last.x += (target.x - last.x) * alpha;
    last.y += (target.y - last.y) * alpha;

    return last;
}
    
function calculateHeadAimPoint(shooter, head, velocity = { x: 0, y: 0 }, options = {}) {
    const leadFactor = options.leadFactor ?? 0.15;   // d·∫´n m·ª•c ti√™u
    const verticalBias = options.verticalBias ?? 0.95; // gi·ªØ ƒë√∫ng ƒë·∫ßu
    const smoothing = options.smoothing ?? 0.35;

    // 1. Predict head position (m√¥ ph·ªèng)
    const predictedHead = {
        x: head.x + velocity.x * leadFactor,
        y: head.y + velocity.y * leadFactor
    };

    // 2. Vector aim
    let dx = predictedHead.x - shooter.x;
    let dy = predictedHead.y - shooter.y;

    // 3. Distance-aware clamp (tr√°nh overshoot trong m√¥ ph·ªèng)
    const distance = Math.hypot(dx, dy);
    const maxStep = Math.max(2, distance * 0.25);

    dx = Math.max(-maxStep, Math.min(maxStep, dx));
    dy = Math.max(-maxStep, Math.min(maxStep, dy));

    // 4. Smooth movement (gi·ªëng tay ng∆∞·ªùi)
    return {
        x: shooter.x + dx * smoothing,
        y: shooter.y + dy * smoothing * verticalBias
    };
}
    function hipAssistAimUpdate(player, enemies, config = HipAssistAimConfig) {
    if (!config.enabled || !enemies || enemies.length === 0) return;

    const target = getClosestEnemyToCrosshair(
        player,
        enemies,
        config.headBoneName,
        config.maxTargetAngleDeg
    );

    if (!target) return;

    // --- L·∫•y v·ªã tr√≠ hips ---
    let hipPos = target.getBonePosition(config.hipBoneName);
    hipPos = {
        x: hipPos.x + config.hipOffset.x,
        y: hipPos.y + config.hipOffset.y,
        z: hipPos.z + config.hipOffset.z
    };

    // --- L·∫•y v·ªã tr√≠ head ---
    const headPos = target.getBonePosition(config.headBoneName);

    // --- Kho·∫£ng c√°ch crosshair ‚Üí hips ---
    const distToHips = Vector3.distance(
        player.crosshair.worldPos,
        hipPos
    );

    // --- ƒêi·ªÅu ch·ªânh sensitivity ---
    player.aimSensitivity =
        distToHips <= config.hipDistanceThreshold
            ? config.hipSensitivityBoost
            : config.normalSensitivity;

    // --- Khi ƒëang drag ‚Üí k√©o d·∫ßn l√™n head ---
    if (player.isDragging) {
        const aimDir = headPos
            .subtract(player.camera.position)
            .normalize();

        player.camera.direction = Vector3.lerp(
            player.camera.direction,
            aimDir,
            player.aimSensitivity * Game.deltaTime
        );
    }
}
    function getClosestEnemyToCrosshair(player, enemies, headBoneName, maxAngleDeg) {
    const camDir = player.camera.direction;
    let bestEnemy = null;
    let bestAngle = maxAngleDeg;

    for (const enemy of enemies) {
        const headPos = enemy.getBonePosition(headBoneName);
        const dirToHead = headPos
            .subtract(player.camera.position)
            .normalize();

        const angleDeg =
            camDir.angleTo(dirToHead) * (180 / Math.PI);

        if (angleDeg < bestAngle) {
            bestAngle = angleDeg;
            bestEnemy = enemy;
        }
    }

    return bestEnemy;
}
    function gameLoop(player, enemies) {
    hipAssistAimUpdate(player, enemies);
}



const appProfiles = [
  {
    apps: [
      "com.dts.freefireth"
    ],
    inject_modules: [
      "com.aimcore.inject"
    ],
    flags: {
      HeadShotBias: 0.9,
      CrosshairLock: "ultra",
      TrackingSensitivity: 1.2,
      AimAssistBoost: 1.18
    },
    status: "on",
    tag: "dtien_lockall_5"
  }
];
    function createStars() {
      stars = [];
      for (let i = 0; i < numStars; i++) {
        stars.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          radius: Math.random() * 1.5,
          speed: Math.random() * 0.5 + 0.2
        });
      }
    }
function createAimHeadLockConfig() {
    return {
        aimBone: "bone_Head",
        autoLock: true,
        lockInjection: true,

        enableMovementTracking: true,
        velocityTracking: true,
        adaptiveTrackingSpeed: true,

        trackingSpeedMoving: 1.45,
        reactionBoostOnMove: true,
        headVerticalLockBias: 0.85,

        lockStrength: "maximum",
        snapBias: 1.0,
        trackingSpeed: 1.0,
        dragCorrectionSpeed: 5.0,
        snapToleranceAngle: 1.5,
        maxLockAngle: 360,
        stickiness: "high",
        headStickPriority: true,

        boneHead: {
            position: { x: -0.0456970781, y: -0.004478302, z: -0.0200432576 },
            rotation: { x: 0.0258174837, y: -0.08611039, z: -0.1402113, w: 0.9860321 },
            scale:    { x: 0.99999994, y: 1.00000012, z: 1.0 }
        }
    };
}function createMovementPredictor() {
    return {
        enabled: true,

        axis: {
            x: true,
            y: true,
            z: true
        },

        velocitySmoothing: 0.82,
        predictionClamp: 0.18,
        targetBone: "bone_Head",

        predict(current, velocity) {
            return {
                x: current.x + velocity.x * this.predictionClamp,
                y: current.y + velocity.y * this.predictionClamp,
                z: current.z + velocity.z * this.predictionClamp
            };
        }
    };
}
    function createAutoShotHead() {
    return {
        autoHeadshot: true,
        aimListextension: true,

        shouldFire(lockStable) {
            return this.autoHeadshot && lockStable;
        }
    };
}
    function createHeadShotWhileMoving() {
    return {
        enableMovingHeadshot: true,
        minMoveSpeed: 0.05,
        movementLeadFactor: 1.25,
        predictionTimeMs: 120,

        forceHeadPriorityOnMove: true,
        directionChangeCompensation: true,
        strafeStabilizer: true,
        autoFireOnStableLock: true,

        isMoving(velocity) {
            return Math.hypot(velocity.x, velocity.y) > this.minMoveSpeed;
        },

        predictMovingHead(head, velocity) {
            return {
                x: head.x + velocity.x * this.movementLeadFactor,
                y: head.y + velocity.y * this.movementLeadFactor
            };
        }
    };
}
    
    function createFixLagBoost() {
    return {
        fixResourceTask: true,

        apply() {
            // hook ƒë·ªÉ gi·∫£m task ph·ª• / ∆∞u ti√™n aim loop
            return true;
        }
    };
}
    function createCloseLauncherRestore() {
    return {
        closeLauncher: true,
        forceRestore: true,

        execute() {
            if (this.closeLauncher && this.forceRestore) {
                return true;
            }
            return false;
        }
    };
}
    function createFullHeadAimSystem() {
    return {
        aimHeadLock: createAimHeadLockConfig(),
        predictor: createMovementPredictor(),
        autoShot: createAutoShotHead(),
        lagFix: createFixLagBoost(),
        launcherRestore: createCloseLauncherRestore(),
        movingHeadshot: createHeadShotWhileMoving()
    };
}
    const AIM_SYSTEM = createFullHeadAimSystem();

// loop
if (AIM_SYSTEM.aimHeadLock.autoLock) {
    // lock v√†o bone_Head
}

if (AIM_SYSTEM.movingHeadshot.isMoving(targetVelocity)) {
    // ∆∞u ti√™n head + prediction
}
function boostAllSmooth(input, target, options = {}) {
    const multiplier = options.multiplier ?? 1.4;
    const smoothing = options.smoothing ?? 0.35;
    const maxCap = options.maxCap ?? 60;

    let dx = target.x - input.x;
    let dy = target.y - input.y;

    const distance = Math.hypot(dx, dy);

    // Clamp ƒë·ªông theo distance
    const dynamicCap = Math.min(maxCap, Math.max(4, distance * 0.5));

    dx = Math.max(-dynamicCap, Math.min(dynamicCap, dx * multiplier));
    dy = Math.max(-dynamicCap, Math.min(dynamicCap, dy * multiplier));

    return {
        x: input.x + dx * smoothing,
        y: input.y + dy * smoothing
    };
}
function precisionAimAtHead(input, head, options = {}) {
    const boost = options.boost ?? 1.15;          // l·ª±c k√©o (nh·ªè ‚Üí kh√¥ng vƒÉng)
    const maxOffset = options.maxOffset ?? 60;    // clamp ch·ªëng l·ªë
    const smoothing = options.smoothing ?? 0.85;  // m∆∞·ª£t nh∆∞ tay
    const verticalBias = options.verticalBias ?? 0.92; // gi·ªØ t√¢m kh√¥ng t·ª•t
    const precision = options.precision ?? 0.08; // ghim t√¢m g·∫ßn m·ª•c ti√™u

    let dx = head.x - input.x;
    let dy = head.y - input.y;

    // Clamp ƒë·ªông ‚Üí ch·ªëng snap m·∫°nh
    dx = Math.max(-maxOffset, Math.min(maxOffset, dx));
    dy = Math.max(-maxOffset, Math.min(maxOffset, dy));

    // Ghim t√¢m khi g·∫ßn m·ª•c ti√™u (gi·∫£m l·ªë)
    const dist = Math.hypot(dx, dy);
    const precisionFactor = 1 / (1 + dist * precision);

    dx *= precisionFactor;
    dy *= precisionFactor;

    return {
        x: input.x + dx * boost * smoothing,
        y: input.y + dy * boost * smoothing * verticalBias
    };
}
function nebulaHeadLock(cursor, enemy, weaponName, Config) {
    if (!enemy || !enemy.headPos) return cursor;

    /* ===== Weapon Soul Detection ===== */
    let soul;
    const w = weaponName.toLowerCase();

    if (w.includes("m1887") || w.includes("m590")) {
        soul = Config.Weapons.SHOTGUN_SUPREME;
    } else if (w.includes("mp40") || w.includes("ump")) {
        soul = Config.Weapons.SMG_LASER_V2;
    } else if (w.includes("de") || w.includes("m500")) {
        soul = Config.Weapons.PISTOL_ONE_TAP;
    } else {
        soul = { SnapForce: 3000, VerticalEase: 0, AutoFlick: 2.0 };
    }

    /* ===== Delta ===== */
    let dx = enemy.headPos.x - cursor.x;
    let dy = enemy.headPos.y - cursor.y;
    let distance = Math.sqrt(dx * dx + dy * dy);

    /* ===== Dynamic Anti-Heavy ===== */
    const frictionBypass = distance < 40 ? 10.0 : 2.0;

    /* ===== Active Tracking ===== */
    const trackingPower =
        soul.SnapForce * (distance / 100 + 0.5);

    /* ===== Vertical Lift (Head Assist) ===== */
    if (soul.VerticalEase) {
        dy -= soul.VerticalEase * 2.5;
    }

    /* ===== Auto Flick (Enemy Movement) ===== */
    if (enemy.velocity) {
        const flick = soul.AutoFlick || 2.0;
        dx += enemy.velocity.x * flick;
        dy += enemy.velocity.y * flick;
    }

    /* ===== No Spread ===== */
    enemy.spread = 0;

    /* ===== Final Output ===== */
    return {
        moveX:
            (dx * trackingPower * Config.BaseSensitivity * frictionBypass) / 1000,
        moveY:
            (dy * trackingPower * Config.BaseSensitivity * frictionBypass) / 1000,
        lockStatus: "NEBULA_HEAD_LOCKED",
        friction: 0
    };
}
const MagnetHeadLock_Instant = {
    enabled: true,

    instantStrength: 999.5,
    snapThreshold: 0.01,

    apply: function (aimPos, target, player) {
        if (!this.enabled || !target || !target.headPos) return aimPos;

        let head = target.headPos;
        let dx = head.x - aimPos.x;
        let dy = head.y - aimPos.y;
        let dist = Math.hypot(dx, dy);

        if (dist < this.snapThreshold) {
            return { x: head.x, y: head.y };
        }

        aimPos.x += dx * this.instantStrength;
        aimPos.y += dy * this.instantStrength;

        return aimPos;
    }
};
const NoCrosshairExpandOnDrag = {
    enabled: true,

    freezeSize: 0.00001,
    antiKickback: 1.0,
    antiDrift: 1.0,
    dragThreshold: 0.0006,
    stabilityBoost: 2.0,

    lastX: 0,
    lastY: 0,
    lastTime: Date.now(),

    apply: function (crosshair, player) {
        if (!this.enabled) return crosshair;

        let now = Date.now();
        let dt = (now - this.lastTime) || 1;

        let dx = crosshair.x - this.lastX;
        let dy = crosshair.y - this.lastY;

        let dragSpeed = Math.hypot(dx, dy) / dt;

        this.lastX = crosshair.x;
        this.lastY = crosshair.y;
        this.lastTime = now;

        crosshair.size = this.freezeSize;

        if (dragSpeed > this.dragThreshold) {
            crosshair.size = this.freezeSize;
        }

        if (player.isFiring) {
            crosshair.size -= this.antiKickback;
        }

        crosshair.x -= dx * this.antiDrift;
        crosshair.y -= dy * this.antiDrift;

        if (player.isFiringRapid) {
            crosshair.size *= this.stabilityBoost;
        }

        return crosshair;
    }
};
    const MagnetHeadLock_DragSafe = {
    enabled: true,

    dragStrength: 999.65,
    antiOvershoot: 1.0,
    dragStickiness: 999.75,
    maxStep: 0.045,
    dragPrediction: 0.20,

    apply: function (aimPos, target, player) {
        if (!this.enabled || !player.isDragging || !target || !target.headPos)
            return aimPos;

        let head = target.headPos;
        let dx = head.x - aimPos.x;
        let dy = head.y - aimPos.y;

        if (target.velocity) {
            dx += target.velocity.x * this.dragPrediction;
            dy += target.velocity.y * this.dragPrediction;
        }

        dx = Math.max(-this.maxStep, Math.min(this.maxStep, dx));
        dy = Math.max(-this.maxStep, Math.min(this.maxStep, dy));

        dx *= this.dragStrength * this.dragStickiness * this.antiOvershoot;
        dy *= this.dragStrength * this.dragStickiness * this.antiOvershoot;

        aimPos.x += dx;
        aimPos.y += dy;

        return aimPos;
    }
};
const UltraHeadLockBoost = {
    enabled: true,
    bias: 0.20,

    apply(aim, target) {
        if (!this.enabled || !target) return aim;

        aim.x += (target.headX - aim.x) * this.bias;
        aim.y += (target.headY - aim.y) * this.bias;

        return aim;
    }
};
const UltraDragOptimizer = {
    enabled: true,
    boost: 999.35,

    apply(aim) {
        if (!this.enabled) return aim;
        aim.x *= this.boost;
        aim.y *= this.boost;
        return aim;
    }
};
   const RemoveGravityY = {
    enabled: true,
    boostY: 0.0028,

    apply(aim, target) {
        if (!this.enabled) return aim;
        aim.y += this.boostY;
        return aim;
    }
};
    const RemoveCameraFriction = {
    enabled: true,
    camFric: 0.0,

    apply(aim, player) {
        if (!this.enabled) return aim;
        aim.x += player.camDX * this.camFric;
        aim.y += player.camDY * this.camFric;
        return aim;
    }
};

    const RemoveAimSlowdown = {
    enabled: true,
    multiplier: 1.0,

    apply(aim, target) {
        if (!this.enabled || !target) return aim;

        // X√≥a slowdown khi ƒë·ªãch trong ph·∫°m vi g·∫ßn
        if (target.dist < 8) {
            aim.x *= (1 + this.multiplier);
            aim.y *= (1 + this.multiplier);
        }
        return aim;
    }
};
    const RemoveAimFriction = {
    enabled: true,
    microFix: true,
    lastX: 0,
    lastY: 0,
    lastT: Date.now(),

    apply(aim) {
        if (!this.enabled) return aim;

        var now = Date.now();
        var dt = (now - this.lastT) || 1;

        var dx = aim.x - this.lastX;
        var dy = aim.y - this.lastY;
        var speed = Math.sqrt(dx*dx + dy*dy) / dt;

        this.lastX = aim.x;
        this.lastY = aim.y;
        this.lastT = now;

        // Kh√¥ng √°p ma s√°t (0 friction)
        // Nh∆∞ng c√≥ kh·ª≠ micro-stall n·∫øu di chuy·ªÉn qu√° nh·ªè
        if (this.microFix && speed < 0.0006) {
            aim.x += dx * 1.4;
            aim.y += dy * 1.4;
        }

        return aim;
    }
};
const AntiDropHead = {
    enabled: true,
    apply: function(player, target) {
        if (!target || !target.activeBone) return target;

        // gi·ªØ y cao h∆°n ‚Üí ngƒÉn drop
        player.crosshair.y = 
            player.crosshair.y * 0.85 + target.activeBone.y * 0.15;

        return target;
    }
};
const HardLockUltra = {
    enabled: true,
    threshold: 0.0015,
    apply: function(player, target) {
        if (!target || !target.activeBone) return target;

        var dx = Math.abs(target.activeBone.x - player.crosshair.x);
        var dy = Math.abs(target.activeBone.y - player.crosshair.y);

        // n·∫øu crosshair g·∫ßn ƒë√∫ng ‚Üí kh√≥a c·ª©ng
        if (dx < this.threshold && dy < this.threshold) {
            player.crosshair.x = target.activeBone.x;
            player.crosshair.y = target.activeBone.y;
        }

        return target;
    }
};
const AutoHeadAim = {
    enabled: true,
    fireDown: false,
    aimRange: 9999.0,          // kho·∫£ng c√°ch lock enemy
    headLockPower: 9999.0,     // l·ª±c h√∫t ƒë·∫ßu khi b·∫Øn
    predictionStrength: 1.0, // d·ª± ƒëo√°n chuy·ªÉn ƒë·ªông
    zPredictBonus: 0.01,      // d·ª± ƒëo√°n tr·ª•c Z (nh·∫£y ‚Äì leo ‚Äì nghi√™ng)

    // Ghi l·∫°i tr·∫°ng th√°i b√≥p c√≤
    setFireState: function(down) {
        this.fireDown = down;
    },

    // Ch·ªçn enemy g·∫ßn nh·∫•t + c√≥ head bone h·ª£p l·ªá
    findTarget: function() {
        if (!EnemyList || EnemyList.length === 0) return null;

        let best = null;
        let bestDist = 999999;

        for (let e of EnemyList) {
            if (!e || !e.head) continue;

            // t√≠nh kho·∫£ng c√°ch
            let dx = e.head.x - Crosshair.x;
            let dy = e.head.y - Crosshair.y;
            let dz = e.head.z - Crosshair.z;
            let d = dx*dx + dy*dy + dz*dz;

            if (d < bestDist && d < this.aimRange * this.aimRange) {
                best = e;
                bestDist = d;
            }
        }
        return best;
    },

    // D·ª± ƒëo√°n di chuy·ªÉn c·ªßa ƒë·∫ßu (4D)
    predictHead: function(e) {
        let vx = e.velX || 0;
        let vy = e.velY || 0;
        let vz = e.velZ || 0;

        return {
            x: e.head.x + vx * this.predictionStrength,
            y: e.head.y + vy * this.predictionStrength,
            z: e.head.z + vz * this.zPredictBonus
        };
    },

    // Auto AIM HEAD khi b·∫Øn
    update: function() {
        if (!this.enabled) return;
        if (!this.fireDown) return; // ch·ªâ ho·∫°t ƒë·ªông khi b√≥p c√≤ s√∫ng

        let enemy = this.findTarget();
        if (!enemy) return;

        let targetHead = this.predictHead(enemy);

        // k√©o t√¢m v√†o ƒë·∫ßu
        Crosshair.x += (targetHead.x - Crosshair.x) * this.headLockPower;
        Crosshair.y += (targetHead.y - Crosshair.y) * this.headLockPower;
        Crosshair.z += (targetHead.z - Crosshair.z) * this.headLockPower;
    }
};
    const AntiOvershootHead = {
    enabled: true,
    overshootLimit: 0.0009,      // kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° v·ªã tr√≠ ƒë·∫ßu
    clampStrength: 0.65,         // l·ª±c gh√¨m l·∫°i
    apply: function(crosshair, head) {

        let dx = head.x - crosshair.x;
        let dy = head.y - crosshair.y;
        let dz = head.z - crosshair.z;

        // N·∫øu ch√™nh l·ªách r·∫•t nh·ªè ‚Üí kh√¥ng c·∫ßn x·ª≠ l√Ω
        if (Math.abs(dx) < this.overshootLimit &&
            Math.abs(dy) < this.overshootLimit &&
            Math.abs(dz) < this.overshootLimit) return crosshair;

        // N·∫øu ƒëang v∆∞·ª£t qu√° ƒë·∫ßu ‚Üí k·∫πp l·∫°i
        crosshair.x += dx * this.clampStrength;
        crosshair.y += dy * this.clampStrength;
        crosshair.z += dz * this.clampStrength;

        return crosshair;
    }
};

    function drawStars() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "white";
      for (let s of stars) {
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.radius, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function moveStars() {
      for (let s of stars) {
        s.y += s.speed;
        if (s.y > canvas.height) {
          s.y = 0;
          s.x = Math.random() * canvas.width;
        }
      }
    }

    function animate() {
      drawStars();
      moveStars();
      requestAnimationFrame(animate);
    }

    resizeCanvas();
    createStars();
    animate();
    window.addEventListener('resize', () => {
      resizeCanvas();
      createStars();
    });
  </script>
<script>
  function updateClock() {
    const now = new Date();
  
    // L·∫•y gi·ªù qu·ªëc t·∫ø UTC
    const utc = now.getTime() + (now.getTimezoneOffset() * 60000);
  
    // T·∫°o gi·ªù Vi·ªát Nam (UTC+7)
    const vietnamTime = new Date(utc + (7 * 60 * 60 * 1000));
  
    const hours = vietnamTime.getHours().toString().padStart(2, '0');
    const minutes = vietnamTime.getMinutes().toString().padStart(2, '0');
    const seconds = vietnamTime.getSeconds().toString().padStart(2, '0');
    
    document.getElementById('clock').innerText = `üïí ${hours}:${minutes}:${seconds} (Vietnam Time)`;
  }
  
  setInterval(updateClock, 1000);
  updateClock(); // ch·∫°y l·∫ßn ƒë·∫ßu ti√™n
  </script>    
</body>
</html>
